# BACnet properties and objects

Шлюз — девайс, в котором определяется

- расписание
- список id девайсов для опроса
- время обновления

## Device

- 11 apduTimeout таймаут для девайса
- 30 deviceAddressBinding ip address or unit
- 73 numberOfApduRetries количество повторов,
- 98 protocolVersion BACnet | ModbusRTU | ModbusTCP
  - мб 97 ?
- 116 timeSynchronizationRecipients Время синхронизации получателей
  - период внутреннего опроса?
- 153 backupFailureTimeout если шлюз не прислал — подсвечивать серым (для сервера)
- 340 restoreCompletionTime период отправки девайса на сервер
    - Параметр update_interval из 371 свойства переместить в отдельное свойство
      updateInterval (118-е)

## Object

- 104 relinquishDefault не опрашивать (опросить единожды при инициализации)
    - НЕ ТО: Значение по умолчанию, используемое в качестве текущего значения, если все
      значения массива приоритетов (Priority_Array) равны NULL (нулю)
- 107 segmentationSupported поддерживается ли несколько сегментов в 1-м запросе

## Modbus Object

- 371 propertyList:
    - Для формулы (A*X) + B: Изменить scale (A) — умножать, а не делить. Также будет
      дополнительный параметр offset (B), который может прибавляться для коррекции.
    - Параметры byteOrder и wordOrder. По умолчанию они будут равны:
      старшим байтом вперед, старшим словом назад. Для обозначения используются символы '
      big' и 'little'. little endian — прямой порядок big endian — обратный порядок Для типа
      32float сейчас используются: byteOrder='>', wordOrder='<'. Для всех других:
      byteOrder='<', wordOrder='>'

- 106 resolution оно нужно для округления значений. Писать отслеживаемый шаг!
  Нужно значение по умолчанию + нужно заполнить его, где оно будет другим.

С типом BOOL не совсем понятно сейчас — там были 16битные — это точно так должно было
работать, что если значение != 0, то пишу 1? Предлагаю ввести тип BIT когда требуется только
один бит (сейчас есть 2 разных BOOL с длиной 1 и с длиной 16)

В поле dataLength была опечатка! Нужно ее поправить. Иначе как я определю в какой тип
декодировать? Могу конечно написать прием через параметр с ошибкой, но что-то не то..

Все параметры из address_cache и rtu.yaml я бы хранил в свойствах объекта девайса. А на
шлюзе только ид девайсов лежали бы. Или вовсе делать запрос на ид девайсов, которые должен
опрашивать данный шлюз, а затем запрашивать объекты.
